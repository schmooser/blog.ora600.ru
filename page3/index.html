<!DOCTYPE html>
<html lang="ru">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Блог Павла Попова</title>
  <meta name="title" content="">
  <meta name="description" content="Павел Попов">

  <meta property="og:url" content="/page3/index.html">
  <meta property="og:title" content="">
  
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="Павел Попов">
  <link rel="icon" type="image/png" href="/public/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="Блог Павла Попова" href="/blog-feed.xml">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic|PT+Sans:400,700,400italic|Roboto:100,300|Roboto+Slab:300,400&amp;subset=latin,cyrillic" rel="stylesheet">
  <link href="/public/css/main.css" rel="stylesheet">

  <!-- CSS -->
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
  <link href="http://fotorama.s3.amazonaws.com/4.4.9/fotorama.css" rel="stylesheet">
  <script src="http://fotorama.s3.amazonaws.com/4.4.9/fotorama.js"></script>
  <script src="/public/js/dug.js"></script>
  <script src="/public/js/application.js"></script>
</head>

<body>
<header class="row-1">
  <nav class="title-nav" role="navigation">
    <h1 class="title-nav-header"><a href="/">Павел Попов</a>
      <span class="title-nav-slash">/</span>
      <a href="/">Блог</a>
    </h1>
  </nav>
</header>

  <section class="entry-list row-1" role="main">
  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/clip-option-in-gnuplot/">Опция clip в gnuplot</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>У gnuplot есть опция <a href="http://gnuplot.sourceforge.net/docs_4.2/node165.html">clip</a>, которая начинает скрывать линии и точки на графике, если они подходят близко к осям. В моем случае, я рисовал линию между двумя точками, причем текущий <code>xrange</code> оказывался по оси <em>x</em> между этими точками, но не захватывал ни одну из них. В этом случае (по-умолчанию point clip is OFF) gnuplot не рисует линию. Пришлось сказать <code>set clip two</code> и линия появилась.</p>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/using-longtabu-in-latex/">Использование longtabu в LaTeX</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>Стандартный <code>tabular</code> не поддерживает таблицы, которые не умещаются в одну страницу.</p>

<p>Для многостраничных таблиц есть пакет <code>longtable</code>, он разбивает таблицу на страницы, 
причем на каждой странице может выводить свой заголовок. Доступны следующие команды:
<code>\endfirsthead</code>, <code>\endhead</code>, <code>\endlastfoot</code>, <code>\endfoot</code>.
Они определяют заголовок на первой странице таблицы и на остальных страницах таблицы.
И подвал страницы на последней и остальных страницах, соответственно.</p>

<p>Примеры использования можно поискать в Гугле или, например, <a href="http://texblog.org/2011/05/15/multi-page-tables-using-longtable/">тут</a>.</p>

<p>Проблемы с <code>longtable</code> начинаются, если в таблице оказываются длинные данные. TeX 
по-умолчанию не умеет переносить содержимое ячеек на новую строчку. Чтобы активировать
перенос тип колонки должен быть не <code>l</code>,<code>r</code> или <code>c</code> (выравнивание влево, вправо или по
центру) а <code>p</code> (параграф) с указанием ширины в понятных для TeXа элементах (например, 
<code>p{1.1cm}</code>). Тогда, определив для каждой колонки размер, соотнеся его с <code>\textwidth</code>
можно добиться нормального расположения таблицы на странице (без сообщений в логе 
<code>Overfull \hbox</code>).</p>

<p>К счастью, есть более правильный способ – использование пакета <a href="http://www.ctan.org/pkg/tabu"><code>tabu</code></a>. Он
добавляет к возможностям окружения <code>tabular</code> новый тип колонок - <code>X</code>. Это колонка,
ширина которой будет вычисляться автоматически.</p>

<p>Пример таблицы в окружении <code>tabu</code>:</p>

<pre><code>\begin{tabu} to \linewidth{lXr}

$r_1c_1$ &amp; $r_1c_2$ &amp; $r_1c_3$ \\
$r_2c_1$ &amp; $r_2c_2$ &amp; $r_2c_3$ \\
$r_3c_1$ &amp; $r_3c_2$ &amp; $r_3c_3$ \\

\end{tabu}
</code></pre>

<p>У <code>X</code> может быть несколько параметров - вес коэффициента ширины ячейки (число),
выравнивание по горизонтали и вертикали. Например, если нужна колонка в 2 раза шире
чем обычная и выровненная по правому краю, для нее указываем <code>X[2,r]</code>.</p>

<p>У пакета <code>tabu</code> есть окружение <code>longtabu</code>, расширяющее функционал пакета <code>longtable</code>
колонками типа <code>X</code>. Чтобы его использовать, надо подключить оба пакета <code>tabu</code> и <code>longtable</code>.</p>

<p>Команды заголовков и подвала <code>longtabu</code> наследует от <code>longtable</code>.</p>

<p>У меня возникли проблемы с <code>longtabu</code> когда у меня в заголовке были многоколоночные
ячейки (<code>\multicolumn</code>). Для них нельзя указать тип <code>X</code>, поэтому заголовок у меня не
попадал в основную таблицу. К сожалению, <code>\multicolumn</code> для <code>tabu</code> еще не реализован,
так что приходится использовать workaround через <code>\tabuphantomline</code>, примерно так:</p>

<pre><code>\begin{longtabu} to \linewidth{|r|X[L]|r|X[L]|r|X[L]|X[R]|l|} \tabucline-

\hline
\multicolumn2{|c|}{COLUMN1} &amp; \multicolumn2{c|}{COLUMN2} &amp; \multicolumn4{c|}{COLUMN3} \\ \tabucline-
\tabuphantomline
\hline
\endfirsthead
...
\end{longtabu}
</code></pre>

<p>Здесь используется таблица с 8 колонками разного типа. Заголовки многоколоночные,
ширина получается точно такая, как у ячеек таблицы.</p>

<p>Использование этого workaround не совсем очевидно из документации, но это работает.</p>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/centos-cheatsheet/">Cheatsheet по CentOS</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>Буду собирать полезные команды по CentOS в одном месте.</p>

<ul>
  <li><code>chkconfig</code> – команда, проверяющая автоматический запуск сервисов. <code>chkconfig
--list httpd</code> покажет, на каких ранлевелах стартует веб-сервер (Апач) при
загрузке. Добавить сервис в автозапуск можно с помощью <code>chkconfig --levels
2345 httpd on</code></li>
  <li>Чтобы подключить <a href="http://fedoraproject.org/wiki/EPEL">EPEL</a>, репозиторий с
большим количеством различных пакетов (например, <code>pip</code> для питона), нужно
поставить rpm-пакет epel. Подробности – в <a href="http://fedoraproject.org/wiki/EPEL/FAQ#How_can_I_install_the_packages_from_the_EPEL_software_repository.3F">FAQ</a> Epel.</li>
  <li>
    <p>Чтобы настроить таймзону нужно скопировать в <code>/etc/localtime</code> одну из таймзон
из <code>/usr/share/zoneinfo</code>, например для Москвы:</p>

    <pre><code># ln -sf /usr/share/zoneinfo/Europe/Moscow localtime
</code></pre>

    <p>Тогда часы сразу изменятся и команда <code>date</code> будет выдавать правильное время.</p>

    <p>Подробности <a href="http://www.cyberciti.biz/faq/howto-linux-unix-change-setup-timezone-tz-variable/">тут</a>.</p>
  </li>
</ul>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/trying-rbenv/">Использование rbenv в качестве менеджера пакетов Ruby</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>Попробовал использовать <a href="https://github.com/sstephenson/rbenv">rbenv</a> в качестве менеджера версий <a href="http://www.ruby-lang.org">ruby</a>. По
сравнению с <a href="https://rvm.io">rvm</a>, который я использовал раньше, это словно глоток свежего
воздуха. Простая и понятная установка, когда сам руками клонируешь нужные
репозитории из гитхаба, 2 строчки в .rc файл и собственно все, установка
закончена. Далее выбираешь нужную версию ruby и поехали. С rvm я никак не мог
понять, в какой версии я нахожусь, что надо сделать, чтобы оно заработало.</p>

<p>Я, конечно, не ruby-разработчик, поэтому это мои “ламерские” выводы, я обеими
системами я работал очень мало, но понятность и простота rbenv подкупают.</p>

<p>Единственное, что не указано в документации в разделе “Установка”, а указано
гораздо ниже – после установки с помощью <code>$ rbenv install ruby-1.9.3-p448</code>
нужно задать используемую версию руби с помощью <code>$ rbenv local 1.9.3-p448</code>.</p>

<p>Также мне понадобилось установить пакет <code>zlib-devel</code> для корректной работы <code>gem
install</code>. Возникала ошибка <a href="http://stackoverflow.com/questions/9727908/cannot-load-such-file-zlib-even-after-using-rvm-pkg-install-zlib">Cannot load such file – zlib</a>.
После установки нужно переустановить версию руби.</p>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/new-features-in-oracle-12c/">12 новых функций Oracle 12c</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>По мотивам этого замечательного видео Тома Кайта</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/ekTTXoHBmWw" frameborder="0" allowfullscreen="">
</iframe>

<p>напишу, о чем Том говорит.</p>

<p>Прежде всего, в Oracle 12c появилось более 500 новых функций, но наиболее
важными по мнению Тома являются следующие (от простых к сложным):</p>

<ol>
  <li>
    <p>Улучшенный PL/SQL внутри SQL. Теперь можно начинать SELECT с PL/SQL-кода,
который потом использовать в запросе, не создавая объект в БД.
Видимо, можно написать что-то вроде:</p>

    <pre><code> with function f(n number)
   return number as
   begin
     return 1;
   end
 select f(1) from dual;
</code></pre>

    <p>Надо будет найти документацию по этому функционалу.</p>
  </li>
  <li>
    <p>Улучшенные значения по-умолчанию. Это про автоинкрементируемые поля типа
IDENTITY, для заполнения последовательностью чисел. Теперь больше не нужно
писать триггеры, заполняющие уникальный ключ из последовательности.
Справедливости ради отмечу, что триггеры почти никто и не писал, просто в
процедуре заполнения использовалась последовательность.</p>

    <p>Также улучшились DEFAULT-значения для колонок. Раньше, если у колонки было
DEFAULT значение, оно использовалось только если колонку не указывать в списке
колонок для вставки. Иначе, вставлялся NULL. Теперь если в колонку с DEFAULT
вставить NULL, вставится DEFAULT. Странно, мне казалось что можно явным образом
указать DEFAULT в INSERT и тогда вставится значение по-умолчанию.</p>

    <p>Можно быстро добавить колонку с DEFAULT, даже если она NULLABLE. Раньше
такое разрешалось только для NOT NULL колонок (фактически на уровне ядра
делалось что-то типа <code>nvl(x, DEFAULT)</code> и физического изменения данных во всей
таблице не происходило)</p>
  </li>
  <li>
    <p>Увеличили максимальный размер типов VARCHAR2, NVARCHAR2 и RAW. В 12с VARCHAR2
может достигать размера в 32k, как в PL/SQL. Где-то видел, что есть настройки и
тонкости с этим, потому что длинные строки Oracle по-прежнему хранит out-of-row
в lob-сегментах. Поищу, поставлю тут ссылку.</p>
  </li>
  <li>
    <p>Top N и постраничные запросы. Раньше это делалось руками через аналитические
функции, теперь добавили синтаксический сахар. Джонатан Льюис
<a href="http://jonathanlewis.wordpress.com/2013/07/10/12c-first-n/">писал</a>, что БД
просто переписывает код в аналитические функции и исполняет. Надо быть
осторожным, а то представляю, во что могут превратятся огромные запросы. Теперь
нагнуть сервер станет гораздо проще.</p>
  </li>
  <li>
    <p>Паттерны строк. Чтобы можно было находить изменения строк в соответствии с
определенными паттернами, например V или W изменения, например котировок акций.
Занятная штука для аналитики.</p>
  </li>
  <li>
    <p>Улучшения партиционирования. Можно делать DDL-операции на несколько партиций
сразу. Перемещения сразу нескольких партиций на другие устройства с сохранением
ONLINE-статуса дата-файлов.</p>
  </li>
  <li>
    <p>Изменяемые планы выполнения. В процессе выполнения запроса оптимизатор
определяет, если он получил на шаге другое количество строк, нежели ожидал, то
он может перестроить план на лету и использовать другой метод соединения.
Например, переключиться с NESTED LOOPS на HASH JOIN. Теперь тюнить запросы без
трейса будет наверное практически невозможно. Хотя, если их не надо будет вообще
тюнить… Мечты.</p>
  </li>
  <li>
    <p>Улучшенная статистика. Новые типы гистограмм (2). Подходят для колонок с
более чем 255-ю различными значениями. Раньше, если уникальных значений больше
255, то строилась сбалансированная по весу гистограмма. У такого подхода были
проблемы с определенными наборами данных. Например, если в столбце есть много
часто встречающиеся значения и много редких значений, а в других столбцах
значения были распределены достаточно равномерно, то старые гистограммы давали
плохую оценку количества возвращаемых строк (cardinality). С новыми типами
гистограмм Oracle 12c хорошо работает с очень частыми значениями,
среднепопулярными и непопулярными значениями. Тут надо почитать подробнее, пока
в голове у меня путаница между столбцами и строками, где популярные значения, в
рамках одного столбца или в рамках нескольких?</p>

    <p>Улучшился сбор статистики. Она теперь собирается на лету при операциях
загрузки данных в пустую таблицу (<code>create table as select</code>, <code>insert /*+ append */</code>,
bulk operations). А если в пустую партицию?</p>
  </li>
  <li>
    <p>UNDO во временном табличном пространстве. Раньше временные таблицы (Global
temporary table) создавались во временном табличном пространстве. Но при
операциях записи во временное табличное пространство создавались блоки в
табличном пространстве UNDO (для согласованного чтения/rollback/commit). А так
как для UNDO информация пишется в REDO-логи, то использование временных таблиц
порождало REDO. Теперь в 12c можно разместить UNDO во временном табличном
пространстве и REDO не будет продуцироваться. Теперь данные из временных таблиц
не попадут в REDO-логи и не будут заархивированы. Это экономия места и времени в
случае восстановления из бэкапа и flashback-операций.</p>
  </li>
  <li>
    <p>Оптимизация данных. БД генерирует “температурные” карты данных - часто
перезаписываемые данные помечаются “горячими”, часточитаемые блоки - “теплыми”,
редкочитаемые - “холодными”. отделяются от редко используемых и от почти
неиспользуемых. Далее в стиле DDL можно указать как БД должна работать с этими
типами данных - можно установить степень сжатия в зависимости от “температуры”
блоков (теплые - сжимать, холодные - в архив). DBA может с декларативно
устанавливать политики для определения температуры блоков и описывать что с ними
делать. БД будет делать это автоматически.</p>
  </li>
  <li>
    <p>Application Continuity и Transaction Guard. Смысл Transaction Guard в том,
что одна транзакция теперь пройдет как минимум один раз и только один раз.
Нельзя два раза оплатить одну и ту же покупку, например. Штука для
веб-приложений типа APEX. Поверх Transaction Guard работает Application
Continuity. Это улучшение существовавшей технологии Transparent Application
Failover (TAF). Раньше с помощью TAF можно было для транзакций только на чтение
распространить ошибку через базы данных. Например, если приложение заполняющее
БД упало, то через TAF эта информация дойдет до приложения (и БД), собирающего
отчеты, например. Проблема в том, что это работало с транзакциями “только на
чтение”. Теперь работает и с транзакциями на запись. Теперь можно поднять
упавшие транзакции и повторить все зависящие от нее транзакции даже на другой
ноде в другой БД.</p>
  </li>
  <li>
    <p>Самое большое изменение – Pluggable Databases. Про эту опцию есть куча
информации, недавно был вебинар (<a href="http://www.youtube.com/watch?v=KKi37EIQ5-8&amp;feature=player_embedded">видео с
него</a>), так
что я особо не буду это описывать. Смысл в том, что если нужно на одном инстансе
поднять несколько баз данных, которые будут полностью независимы, то теперь не
нужно создавать несколько ORACLE_HOME и запускать несколько экземпляров инстанса
Oracle. Раньше нельзя было объединить БД потому что возник бы конфликт
синонимов, наименований схем и т.д. Теперь это подключается как pluggable
database, на лету создается, подключается, клонируется, отключается. Одна SGA на
инстанс, которая будет существенно меньше чем куча маленьких SGA для каждой БД.
Бэкап, установка обновлений – все на одну контэйнер-БД. Подключаемые БД
автоматически унаследуют все с БД-контейнера. Собственно эта функция и дала
Oracle 12с буковку <em>c</em> в названии.</p>
  </li>
</ol>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/annuity-calculator/">Аннуитетный калькулятор</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>Написал на Питоне коротенький аннуитетный калькулятор, рассчитывающий размер
платежа, начисленные проценты и общую сумму переплаты. </p>

<p>Оказалось, что если взять кредит на 3 года и погашать досрочно суммами, равными
аннуитетному платежу для срока кредита 1 год, то переплата процентов будет в
точности равна переплате, если просто взять кредит на 1 год.</p>

<p>Калькулятор:</p>

<pre><code># -*- encoding: utf-8 -*-

PCT = 14.99/100
YEARS = 2
m = 12  # number of payments in year

SUM = 100000

K = (PCT/m)/(1-(1+(PCT/m))**(-1*YEARS*m))  # annuity quotient

def iterate():
  global SUM, K, YEARS, m
  remainder = SUM
  extra = 0  # extra monthly payment 
  totals = {'percents': 0, 'payments': 0}
  print('{:&lt;10}\t{:&lt;10}\t{:&lt;10}\t{:&lt;10}\t{:&lt;10}'.format('MONTH', 'PERCENT', 'PAYMENT',
                                                        'REMAINDER', 'EXTRA'))
  for i in range(YEARS*m):
    percent = remainder*PCT/m
    remainder += percent        
    payment = min(K*SUM + extra, remainder)
    remainder = max(0, remainder - payment)
    totals['percents'] += percent
    totals['payments'] += payment
    print('{:&lt;10}\t{:&lt;10.2f}\t{:&lt;10.2f}\t{:&lt;10.2f}\t{:&lt;10.2f}'.format(i+1, percent, payment,
                                                                      remainder, extra))
    if remainder == 0: break
  print('-'*80)
  print('{:&lt;10}\t{:&lt;10.2f}\t{:&lt;10.2f}'.format('TOTAL', totals['percents'],
                                              totals['payments']))

iterate()
</code></pre>

<p>Пример расчета кредита в 100,000 на 2 года с процентной ставкой 14.99% годовых:</p>

<pre><code>MONTH       PERCENT   	PAYMENT   	REMAINDER 	EXTRA     
1         	1249.17   	4848.19   	96400.98  	0.00      
2         	1204.21   	4848.19   	92757.00  	0.00      
3         	1158.69   	4848.19   	89067.50  	0.00      
4         	1112.60   	4848.19   	85331.91  	0.00      
5         	1065.94   	4848.19   	81549.66  	0.00      
6         	1018.69   	4848.19   	77720.16  	0.00      
7         	970.85    	4848.19   	73842.82  	0.00      
8         	922.42    	4848.19   	69917.05  	0.00      
9         	873.38    	4848.19   	65942.24  	0.00      
10        	823.73    	4848.19   	61917.78  	0.00      
11        	773.46    	4848.19   	57843.05  	0.00      
12        	722.56    	4848.19   	53717.41  	0.00      
13        	671.02    	4848.19   	49540.24  	0.00      
14        	618.84    	4848.19   	45310.90  	0.00      
15        	566.01    	4848.19   	41028.71  	0.00      
16        	512.52    	4848.19   	36693.04  	0.00      
17        	458.36    	4848.19   	32303.21  	0.00      
18        	403.52    	4848.19   	27858.54  	0.00      
19        	348.00    	4848.19   	23358.35  	0.00      
20        	291.78    	4848.19   	18801.95  	0.00      
21        	234.87    	4848.19   	14188.62  	0.00      
22        	177.24    	4848.19   	9517.67   	0.00      
23        	118.89    	4848.19   	4788.37   	0.00      
24        	59.81     	4848.19   	0.00      	0.00      
--------------------------------------------------------------------------------
TOTAL     	16356.55  	116356.55 
</code></pre>

<p>Формулу для аннуитета взял в <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BD%D1%83%D0%B8%D1%82%D0%B5%D1%82">Википедии</a>.</p>

<p><a href="https://github.com/schmooser/cloaked-adventure/blob/master/annuity_calc.py">Исходный код</a> на ГитХабе.</p>



    
  </div>

  
</article>

  
    
  
  
  



  


<article class="entry">
  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/export-dbf-to-csv/">Экспорт из dbf в csv</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>Чтобы экспортировать dbf в csv, можно использовать питоновский модуль <a href="https://pypi.python.org/pypi/dbf">dbf</a>.</p>

<p>Иногда требуется указать явным образом кодировку, в которой хранятся данные в dbf-файле.</p>

<pre><code>import dbf

dbf_file = 'd:\\in.dbf'
csv_file = 'd:\\out.csv'

a = dbf.Table(dbf_file)
a.open()
a.codepage = dbf.CodePage('cp866')

dbf.export(a, filename=csv_file, encoding='cp1251', format='csv')
</code></pre>

<hr />

<p>Обнаружилась проблема, что модуль dbf для определенных типов атрибутов заменяет NULL-значения на текст None. Поискал в интернете другой модуль, нашел <a href="http://dbfpy.sourceforge.net/">dbfpy</a>. Работает даже быстрее чем dbf. Скрипт выгрузки становится таким:</p>

<pre><code>from dbfpy import dbf
import csv

dbf_file = 'd:\\in.dbf'
csv_file = 'd:\\out.csv'

db = dbf.Dbf(dbf_file)
writer = csv.writer(open(csv_file, 'w'), delimiter = '\t', lineterminator='\n',
                    quotechar="'", quoting=csv.QUOTE_NONE)
                
# print db.fieldNames

i = 0
for rec in db:
  row = [item for item in rec]
  writer.writerow(row)
  i += 1
  if i%100000 == 0:
    print '%d rows downloaded' % i

print 'Done: %d rows downloaded' % i
</code></pre>

<p>Конверсии кодировки нет, в какой был текст в исходном dbf, в таком он будет и в csv.</p>



    
  </div>

  
</article>

  
  <a href="archive.html" class="archive-link">→</a>
</section>



  <!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21201856 = new Ya.Metrika({id:21201856,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/21201856" style="position:absolute; left:-9999px;" alt="" /></div>
</noscript>
<!-- /Yandex.Metrika counter -->

</body>
</html>
