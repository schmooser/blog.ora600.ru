<!DOCTYPE html>
<html lang="ru">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Блог Павла Попова</title>
  <meta name="title" content="12 новых функций Oracle 12c">
  <meta name="description" content="Павел Попов">

  <meta property="og:url" content="/new-features-in-oracle-12c/">
  <meta property="og:title" content="12 новых функций Oracle 12c">
  
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="Павел Попов">
  <link rel="icon" type="image/png" href="/public/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="Блог Павла Попова" href="/blog-feed.xml">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic|PT+Sans:400,700,400italic|Roboto:100,300|Roboto+Slab:300,400&amp;subset=latin,cyrillic" rel="stylesheet">
  <link href="/public/css/main.css" rel="stylesheet">

  <!-- CSS -->
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
  <link  href="http://fotorama.s3.amazonaws.com/4.6.0/fotorama.css" rel="stylesheet"> <!-- 3 KB -->
<script src="http://fotorama.s3.amazonaws.com/4.6.0/fotorama.js"></script> <!-- 16 KB -->
  <script src="/public/js/dug.js"></script>
  <script src="/public/js/application.js"></script>
</head>

<body>
<header class="row-1">
  <nav class="title-nav" role="navigation">
    <h1 class="title-nav-header"><a href="/">Павел Попов</a>
      <span class="title-nav-slash">/</span>
      <a href="/">Блог</a>
    </h1>
  </nav>
</header>

  <section class="single-entry row-1" role="main">
  <article class="entry">
    
  
  
  




  <header class="entry-header">
    <h1 class="entry-title">
      <a href="/new-features-in-oracle-12c/">12 новых функций Oracle 12c</a>
    </h1>
  </header>

  <div class="entry-body content-area">
    

    <p>По мотивам этого замечательного видео Тома Кайта</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/ekTTXoHBmWw" frameborder="0" allowfullscreen="">
</iframe>

<p>напишу, о чем Том говорит.</p>

<p>Прежде всего, в Oracle 12c появилось более 500 новых функций, но наиболее
важными по мнению Тома являются следующие (от простых к сложным):</p>

<ol>
  <li>
    <p>Улучшенный PL/SQL внутри SQL. Теперь можно начинать SELECT с PL/SQL-кода,
который потом использовать в запросе, не создавая объект в БД.
Видимо, можно написать что-то вроде:</p>

    <pre><code> with function f(n number)
   return number as
   begin
     return 1;
   end
 select f(1) from dual;
</code></pre>

    <p>Надо будет найти документацию по этому функционалу.</p>
  </li>
  <li>
    <p>Улучшенные значения по-умолчанию. Это про автоинкрементируемые поля типа
IDENTITY, для заполнения последовательностью чисел. Теперь больше не нужно
писать триггеры, заполняющие уникальный ключ из последовательности.
Справедливости ради отмечу, что триггеры почти никто и не писал, просто в
процедуре заполнения использовалась последовательность.</p>

    <p>Также улучшились DEFAULT-значения для колонок. Раньше, если у колонки было
DEFAULT значение, оно использовалось только если колонку не указывать в списке
колонок для вставки. Иначе, вставлялся NULL. Теперь если в колонку с DEFAULT
вставить NULL, вставится DEFAULT. Странно, мне казалось что можно явным образом
указать DEFAULT в INSERT и тогда вставится значение по-умолчанию.</p>

    <p>Можно быстро добавить колонку с DEFAULT, даже если она NULLABLE. Раньше
такое разрешалось только для NOT NULL колонок (фактически на уровне ядра
делалось что-то типа <code>nvl(x, DEFAULT)</code> и физического изменения данных во всей
таблице не происходило)</p>
  </li>
  <li>
    <p>Увеличили максимальный размер типов VARCHAR2, NVARCHAR2 и RAW. В 12с VARCHAR2
может достигать размера в 32k, как в PL/SQL. Где-то видел, что есть настройки и
тонкости с этим, потому что длинные строки Oracle по-прежнему хранит out-of-row
в lob-сегментах. Поищу, поставлю тут ссылку.</p>
  </li>
  <li>
    <p>Top N и постраничные запросы. Раньше это делалось руками через аналитические
функции, теперь добавили синтаксический сахар. Джонатан Льюис
<a href="http://jonathanlewis.wordpress.com/2013/07/10/12c-first-n/">писал</a>, что БД
просто переписывает код в аналитические функции и исполняет. Надо быть
осторожным, а то представляю, во что могут превратятся огромные запросы. Теперь
нагнуть сервер станет гораздо проще.</p>
  </li>
  <li>
    <p>Паттерны строк. Чтобы можно было находить изменения строк в соответствии с
определенными паттернами, например V или W изменения, например котировок акций.
Занятная штука для аналитики.</p>
  </li>
  <li>
    <p>Улучшения партиционирования. Можно делать DDL-операции на несколько партиций
сразу. Перемещения сразу нескольких партиций на другие устройства с сохранением
ONLINE-статуса дата-файлов.</p>
  </li>
  <li>
    <p>Изменяемые планы выполнения. В процессе выполнения запроса оптимизатор
определяет, если он получил на шаге другое количество строк, нежели ожидал, то
он может перестроить план на лету и использовать другой метод соединения.
Например, переключиться с NESTED LOOPS на HASH JOIN. Теперь тюнить запросы без
трейса будет наверное практически невозможно. Хотя, если их не надо будет вообще
тюнить… Мечты.</p>
  </li>
  <li>
    <p>Улучшенная статистика. Новые типы гистограмм (2). Подходят для колонок с
более чем 255-ю различными значениями. Раньше, если уникальных значений больше
255, то строилась сбалансированная по весу гистограмма. У такого подхода были
проблемы с определенными наборами данных. Например, если в столбце есть много
часто встречающиеся значения и много редких значений, а в других столбцах
значения были распределены достаточно равномерно, то старые гистограммы давали
плохую оценку количества возвращаемых строк (cardinality). С новыми типами
гистограмм Oracle 12c хорошо работает с очень частыми значениями,
среднепопулярными и непопулярными значениями. Тут надо почитать подробнее, пока
в голове у меня путаница между столбцами и строками, где популярные значения, в
рамках одного столбца или в рамках нескольких?</p>

    <p>Улучшился сбор статистики. Она теперь собирается на лету при операциях
загрузки данных в пустую таблицу (<code>create table as select</code>, <code>insert /*+ append */</code>,
bulk operations). А если в пустую партицию?</p>
  </li>
  <li>
    <p>UNDO во временном табличном пространстве. Раньше временные таблицы (Global
temporary table) создавались во временном табличном пространстве. Но при
операциях записи во временное табличное пространство создавались блоки в
табличном пространстве UNDO (для согласованного чтения/rollback/commit). А так
как для UNDO информация пишется в REDO-логи, то использование временных таблиц
порождало REDO. Теперь в 12c можно разместить UNDO во временном табличном
пространстве и REDO не будет продуцироваться. Теперь данные из временных таблиц
не попадут в REDO-логи и не будут заархивированы. Это экономия места и времени в
случае восстановления из бэкапа и flashback-операций.</p>
  </li>
  <li>
    <p>Оптимизация данных. БД генерирует “температурные” карты данных - часто
перезаписываемые данные помечаются “горячими”, часточитаемые блоки - “теплыми”,
редкочитаемые - “холодными”. отделяются от редко используемых и от почти
неиспользуемых. Далее в стиле DDL можно указать как БД должна работать с этими
типами данных - можно установить степень сжатия в зависимости от “температуры”
блоков (теплые - сжимать, холодные - в архив). DBA может с декларативно
устанавливать политики для определения температуры блоков и описывать что с ними
делать. БД будет делать это автоматически.</p>
  </li>
  <li>
    <p>Application Continuity и Transaction Guard. Смысл Transaction Guard в том,
что одна транзакция теперь пройдет как минимум один раз и только один раз.
Нельзя два раза оплатить одну и ту же покупку, например. Штука для
веб-приложений типа APEX. Поверх Transaction Guard работает Application
Continuity. Это улучшение существовавшей технологии Transparent Application
Failover (TAF). Раньше с помощью TAF можно было для транзакций только на чтение
распространить ошибку через базы данных. Например, если приложение заполняющее
БД упало, то через TAF эта информация дойдет до приложения (и БД), собирающего
отчеты, например. Проблема в том, что это работало с транзакциями “только на
чтение”. Теперь работает и с транзакциями на запись. Теперь можно поднять
упавшие транзакции и повторить все зависящие от нее транзакции даже на другой
ноде в другой БД.</p>
  </li>
  <li>
    <p>Самое большое изменение – Pluggable Databases. Про эту опцию есть куча
информации, недавно был вебинар (<a href="http://www.youtube.com/watch?v=KKi37EIQ5-8&amp;feature=player_embedded">видео с
него</a>), так
что я особо не буду это описывать. Смысл в том, что если нужно на одном инстансе
поднять несколько баз данных, которые будут полностью независимы, то теперь не
нужно создавать несколько ORACLE_HOME и запускать несколько экземпляров инстанса
Oracle. Раньше нельзя было объединить БД потому что возник бы конфликт
синонимов, наименований схем и т.д. Теперь это подключается как pluggable
database, на лету создается, подключается, клонируется, отключается. Одна SGA на
инстанс, которая будет существенно меньше чем куча маленьких SGA для каждой БД.
Бэкап, установка обновлений – все на одну контэйнер-БД. Подключаемые БД
автоматически унаследуют все с БД-контейнера. Собственно эта функция и дала
Oracle 12с буковку <em>c</em> в названии.</p>
  </li>
</ol>



    
  </div>

  
  <footer class="entry-footer">
    <time class="entry-timestamp">22 Jul 2013</time>
  </footer>
  

  </article>
</section>



  <!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21201856 = new Ya.Metrika({id:21201856,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/21201856" style="position:absolute; left:-9999px;" alt="" /></div>
</noscript>
<!-- /Yandex.Metrika counter -->

</body>
</html>
