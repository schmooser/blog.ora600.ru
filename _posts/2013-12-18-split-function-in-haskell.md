---
layout: post
lang: ru
title: Функция split на Haskell
category: haskell
description: Пишу первую функцию на Haskell - split, разбивающую строку на массив из строк.
---

В проекте [OraVCS] для создания пользователя используется стандартное выражение:

    CREATE USER <username> IDENTIFIED BY <password> ...

Имя пользователя и пароль задаются в строке соединения, которая имеет вид

    <username>/<password>@<database>

где `<database>` -- TNS-идентификатор инстанса или вид

    <username>/<password>@[//]<host>[:<port>][/<service>]
    
в случае ипользования [EZConnect]-формата.

Для получения username и password из строки соединения `es` сейчас используется простой регэксп:

    username, password = re.split('\W+', es)[0:2]

Данный регэксп сработает некорректно, если в пароле или имени вдруг окажется символы, трактуемые как граница слова, например $%^&*()_+, а они, в пароле вполне допустимы. 

    >>> es = 'user_name/pa$$wor*d@db'
    >>> re.split('\W+', es)
    ['user_name', 'pa', 'wor', 'd', 'db']

Поэтому, данный кусок надо как-то переписать. Например, так:

    >>> username = es.split('/')[0]
    >>> password = es.split('/')[1].split('@')[0]
    >>> username, password
    ('user_name', 'pa$$wor*d')

Но, определение пароля какое-то не очень красивое. Гораздо лучше было бы написать что-нибудь вроде

    username, password = split(s=es, dlm='/@')[0:2]
    
где функция `split` разбивает строку на массив элементов с разделителями, перечисленными в `dlm`. Такую функцию на питоне написать довольно легко:

    def split(s, dlm):
        acc, elm = [], ''
        for c in list(s):
            if c in dlm and elm != '':
                acc.append(elm)
                elm = ''
            else:
                elm += c
        return acc
    
    es = 'user_name/pa$$wor*d@db'
    username, password = split(s=es, dlm='/@')[0:2]
    assert (username, password) == ('user_name', 'pa$$wor*d')    

Но я захотел написать ее в функциональном стиле. Т.к. питон это не чисто-функциональный язык и некоторых вещей в нем нет, я решил сначала написать эту функцию на Haskell.

Понятно, что наверное в Haskell она уже реализована в каком-нибудь Data.List, но я решил ее написать самостоятельно не заглядывая в гугл. Сигнатура функции должна быть такой:

    split :: [Char] -> [Char] -> [[Char]]

Т.е. на вход массив символов (строка) и массив символов (разделитель), на выход - массив массивов символов (массив строк).

Подумав пару часов, я написал следующие функции:

    in' :: Char -> [Char] -> Bool
    in' _ [] = False
    in' c (x:xs) = x == c || c `in'` xs
    
    type Delimiter = String 
    type Accumulator = [String] 
    
    rsplit :: String -> Delimiter -> Accumulator -> [String]
    rsplit [] _ acc = acc
    rsplit (x:xs) dlm acc
        | x `in'` dlm = sp ([]:acc)
        | null acc    = sp ([x]:[])
        | otherwise   = sp $ (x:head acc):tail acc
        where sp  = rsplit xs dlm
    
    split :: String -> Delimiter -> [String]
    split x dlm = map reverse $ reverse $ rsplit x dlm []

Функция `in'` возвращает True если символ входит в строку. Вся логика в функции `rsplit`, она то и возвращает разделенную строку, правда и элементы и строки в обратном порядке, поэтому есть еще функция `split`, оборачивающая результат работы `rsplit`.

Логика работы функции `rsplit` следующая: на вход - строка, строка с разделителями и аккумулятор, на выход - результат (массив из строк). 

Аккумулятор это тот же массив из строк, в котором будет накапливаться результат и когда обработали все символы аккумулятор возвращается в виде результата. Именно это и записано в строке:

        rsplit [] _ acc = acc

Далее, анализируем строку посимвольно (`rsplit (x:xs) dlm acc`):

* Если текущий символ `x` входит в разделитель, то мы дошли до разделителя. В аккумулятор добавляем новый пустой элемент и рекурсивно вызываем саму функцию на оставшихся символах. Это строка

      | x `in'` dlm = sp ([]:acc)

   За `sp` обозначено частичное применение функции двумя параметрами без аккумулятора: `sp  = rsplit xs dlm`. Над этим куском я думал больше всего.

* Если аккумулятор пустой, то добавляем текущий символ в новый элемент аккумулятора и рекурсивно  вызываем функцию на оставшихся символах с новым аккумулятором:

      | null acc    = sp ([x]:[])

* В остальных случаях, то есть шаг не первый и текущий символ не разделитель, мы берем первый элемент аккумулятора, добавляем к нему символ, конструируем новый аккумулятор с добавленным символом и рекурсивно  вызываем функцию на оставшихся символах с новым аккумулятором:

      | otherwise   = sp $ (x:head acc):tail acc

Получилось довольно изящно. Конечно, путем поиска в гугле, я сразу нашел подобный вопрос на [StackOverflow]. Там решения очень изящные (переработанные версии функции `words`, разделяющей строку на слова), но мне было приятно самому написать свою первую серьезную функцию на Haskell.


[EZConnect]: http://www.orafaq.com/wiki/EZCONNECT
[OraVCS]: https://github.com/schmooser/OraVCS
[StackOverflow]: http://stackoverflow.com/questions/4978578/how-to-split-a-string-in-haskell
